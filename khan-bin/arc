#!/usr/bin/env python2

"""A wrapper script around arcanist's arc (part of the phabricator suite).

This wrapper allows a few options that arc does not, and also provides
a bit extra functionality.  Most of it is around 'arc diff' -- it
allows specifying reviewers on the commandline, and checking that
reviewer names are legal before putting up the form.  (A bit more
expensive, which is why phabricator doesn't do that by default
probably, but well worth it.)
"""

import errno
import json
import os
import pty
import re
import select
import subprocess
import sys
import time


try:
    _DEFAULT_ARC_ROOT = os.path.dirname(os.path.dirname(__file__))
except NameError:     # __file__ not defined
    _DEFAULT_ARC_ROOT = '..'


def _update_arcrc(arc_root, default_arcrc_file='khan-bin/khan-arcrc',
                  user_arcrc_file='~/.arcrc', create_bak=True):
    """Update the user's .arcrc to include the contents of the standard one.

    This directory has khan-arcrc, which has the Khan-specific
    configuration options.  It can get updated from time to time.
    When this happens, we want to incorporate the updates into the
    user's .arcrc.  This routine does this.

    If the user's .arcrc has a section like
      'khan': {'do_not_auto_update': ['foo/bar', 'baz']}
    then this update process will skip the fields
    arcrc['foo']['bar'] and ['baz'] when updating the user's .arcrc.

    Arguments:
      arc_root: the root of the arcanist repository.
      default_arcrc_file: where the khan-system .arcrc file lives,
         relative to arc-root.
      user_arcrc_file: where the user's .arcrc file lives, relative to
         arc-root (so should usually be an absolute path).  Can include ~.
      create_bak: whether to copy the .arcrc to .arcrc.bak before updating
         its contents.
    """
    default_arcrc_file = os.path.join(arc_root, default_arcrc_file)
    default_arcrc = json.load(open(default_arcrc_file))

    user_arcrc_file = os.path.expanduser(user_arcrc_file)
    user_arcrc_file = os.path.join(arc_root, user_arcrc_file)
    try:
        user_arcrc = json.load(open(user_arcrc_file))
    except (IOError, OSError):
        user_arcrc = {}

    do_not_update = user_arcrc.get('khan', {}).get('do_not_auto_update', [])

    # Now update user_arcrc with the contents of default_arcrc.
    def _add_or_replace(from_root, to_root, key_path, do_not_update):
        """Recursively merges maps in from_root with to_root."""
        num_updates = 0
        for k in from_root:
            new_key_path = key_path + ('/' if key_path else '') + k
            if new_key_path in do_not_update:
                pass
            elif (isinstance(from_root.get(k), dict) and
                  isinstance(to_root.get(k), dict)):
                num_updates += _add_or_replace(from_root[k], to_root[k],
                                               new_key_path, do_not_update)
            elif to_root.get(k) != from_root.get(k):
                print >>sys.stderr, (
                    'Updating %s:%s to match the default value in %s.\n'
                    '  WAS: %s\n'
                    '  NOW: %s\n'
                    'If this was wrong, recover your old .arcrc from %s.bak\n'
                    'and add "%s" to %s:khan/do_not_auto_update.'
                    % (user_arcrc_file, new_key_path, default_arcrc_file,
                       to_root.get(k, '<empty>'), from_root.get(k, '<empty>'),
                       user_arcrc_file, new_key_path, user_arcrc_file))
                to_root[k] = from_root[k]
                num_updates += 1
        return num_updates

    num_updates = _add_or_replace(default_arcrc, user_arcrc, '', do_not_update)

    # As a migration step: if config.default is for an https url,
    # but we only have an http certificate, rename it to be an
    # https certificate instead.
    if user_arcrc.get('config', {}).get('default', '').startswith("https://"):
        hosts = user_arcrc.get('hosts', {})
        if hosts:
            http_cert = hosts.get('http://phabricator.khanacademy.org/api/')
            https_cert = hosts.get('https://phabricator.khanacademy.org/api/')
            if http_cert and not https_cert:   # http is canonical
                print >>sys.stderr, 'Copying your cert key from http to https'
                hosts['https://phabricator.khanacademy.org/api/'] = http_cert
                num_updates += 1

    # TODO(csilvers): delete the http cert, if the https cert exists, once
    #                 all .arcconfig's have moved to specifying the https
    #                 host for the conduit-uri.

    if num_updates:
        bak_filename = user_arcrc_file + '.bak'
        if create_bak and os.path.exists(user_arcrc_file):
            os.rename(user_arcrc_file, bak_filename)
        try:
            with open(user_arcrc_file, 'w') as f:
                json.dump(user_arcrc, f, indent=2, sort_keys=True)
            os.chmod(user_arcrc_file, 0o600)
        except:
            if os.path.exists(bak_filename):
                if os.path.exists(user_arcrc_file):  # in an inconsistent state
                    os.unlink(user_arcrc_file)
                os.rename(bak_filename, user_arcrc_file)
            raise


def _git_pull_in_dir(dir_to_pull):
    try:
        subprocess.check_call(['git', 'pull', '-q'], cwd=dir_to_pull)
    except subprocess.CalledProcessError, why:
        sys.exit('While updating the arc binary, "git pull" failed in %s: %s.'
                 ' Make sure the repo is clean.' % (dir_to_pull, str(why)))


def _sync_arc(arc_root):
    """Make sure we're using the most up-to-date version of arc.

    Updates arcanist and libphutil repositories.  Since this takes a
    few seconds, we only do it once a day.

    We also make sure the user's .arcrc file is up to date.

    Arguments:
      arc_root: the root of the arcanist repository.  It is expected
          that the libphutil repository be a sibling of arcanist.
    """
    try:
        # TODO(csilvers): use ~/.arc.pull or /tmp/arc.pull.<uid>
        last_pull_time = os.stat('/tmp/arc.pull').st_mtime
    except (IOError, OSError):
        last_pull_time = 0
    if last_pull_time + 24 * 60 * 60 >= time.time():
        return

    # TODO(csilvers): better to call 'arc upgrade' here instead.
    libphutil_root = os.path.join(os.path.dirname(arc_root), 'libphutil')
    _git_pull_in_dir(arc_root)
    _git_pull_in_dir(libphutil_root)

    # Update the user's .arcrc with the default values (which may have
    # changed due to the pull).
    _update_arcrc(arc_root)

    # Also update our cache of usernames, for username completion with --rr.
    try:
        _get_user_info(arc_root, use_cache=False)   # updates the cache
    except RuntimeError:        # probably means we don't have an ssh key
        pass

    open('/tmp/arc.pull', 'w').close()    # update the last-pull time.


def _conduit_call(arc_root, conduit_name, json_input={}):
    """Make an 'arc call-conduit' call with the given input."""
    arc = os.path.join(arc_root, 'bin', 'arc')
    p = subprocess.Popen([arc, 'call-conduit', conduit_name],
                         stdout=subprocess.PIPE, stdin=subprocess.PIPE)
    conduit_stdout = p.communicate(input=json.dumps(json_input))[0]
    if p.returncode != 0:
        raise RuntimeError('Error getting %s info from phabricator: %s'
                           % (conduit_name, conduit_stdout))

    retval = json.loads(conduit_stdout)
    if retval.get('Error'):
        raise RuntimeError('Error getting %s info from phabricator: %s'
                           % (conduit_name, retval['errorMessage']))
    return retval['response']


class NotGitError(Exception):
    """Called git when not in a git repository."""


def _git_call(git_args):
    """Make a 'git' call and return the result.

    Raises NotGitError if run outside a git repo, or CalledProcessError
    if the git command fails for some other reason."""
    try:
        return subprocess.check_output(['git'] + git_args,
                                       stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError, why:
        if 'Not a git repository' in str(why):
            raise NotGitError()
        raise


def _try_save(filename, json_contents):
    try:
        with open(filename + '.tmp', 'w') as f:
            json.dump(json_contents, f)
        if os.path.exists(filename):
            os.unlink(filename)      # atomic rename
        os.rename(filename + '.tmp', filename)
    except (IOError, OSError):
        pass


def _get_user_info(arc_root, use_cache):
    """Retrieve a list of (username, realname) pairs of all phab. users."""
    if use_cache:
        try:
            # TODO(csilvers): use ~/.arc.usernames or /tmp/arc.usernames.<uid>
            with open('/tmp/arc.usernames') as f:
                return json.load(f)
        except (IOError, OSError, ValueError):
            pass

    user_info = _conduit_call(arc_root, 'user.query', {'limit': 1000000})
    retval = [(ui['userName'], ui['realName']) for ui in user_info
              if ('disabled' not in ui['roles'] and
                  'unverified' not in ui['roles'])]

    # Might as well update the cache while we've got all this data...
    _try_save('/tmp/arc.usernames', retval)
    return retval


def _get_project_info(arc_root, use_cache):
    """Retrieve a list of project_names of all active phabricator projects."""
    if use_cache:
        try:
            with open('/tmp/arc.projectnames') as f:
                return json.load(f)
        except (IOError, OSError, ValueError):
            pass

    project_info = _conduit_call(arc_root, 'project.query', {'limit': 1000000})
    retval = [pi['name'] for pi in project_info['data'].itervalues()
              if pi['color'] != 'disabled']

    _try_save('/tmp/arc.projectnames', retval)
    return retval


def _pick_a_number(prompt, max_number):
    """Prompt the user to pick a number from 1 to max_number, and return it."""
    try:
        pick = int(raw_input(prompt))
    except ValueError:
        raise ValueError('You must specify a number')
    if pick not in range(1, max_number + 1):
        raise IndexError('You must specify a number between 1 and %s'
                         % max_number)
    return pick


def normalize_usernames(arc_root, names, use_arc_caches=True):
    """Given a list of names or name substrings, return a list of usernames.

    The input names can be a phabricator username, or a (part of a)
    real name, or a substring of either.  It can also be a prefix of a
    phabricator project-name, including the leading '#'
    (e.g. '#infra').

    We normalize as follows.

    1) If the input name starts with @, or ends with @, we take it to
    be a username, and normalize to that ("alpert@" and "@alpert" both
    normalize to the user with username "alpert").

    2) If the input name is equal to one or more user's first-name,
    last-name, or username, those are the candidate users.  If there's
    only one candidate, we normalize to that user, otherwise we ask
    the client to pick the user.  If there are no candidates, we go to
    the next step.

    3) If the input name is a substring of "username (firstname
    lastname)" for one or more users, those are the candidate users.
    If there's only one candidate, we normalize to that user,
    otherwise we ask the client to pick the user.  If there are no
    candidates, raise a NameError.

    Arguments:
      arc_root: the root of the arcanist repository on the local filesystem.
      names: a list (or anything iterable) of strings.
      use_arc_caches: speed this up by using a cache.  Mostly for
          internal use.

    Returns:
      A list of phabricator usernames, in the same order as names.
      For a given name, the phabricator username is determined as
      described above.

    Raises:
      NameError: if an input name matches no name in the phabricator db.

    """
    # This code is adapted from github.com:Khan/kiln-review's review.py
    if not names:
        return []

    retval = []
    # Small optimization: if all args are @name/name@, no need for user-info.
    if not all(n.strip().endswith('@') or n.strip().startswith('@')
               for n in names):
        user_info = _get_user_info(arc_root, use_cache=use_arc_caches)
        # For ease of searching, we'll create a map from lowercase
        # username to username/realname, and also from lowercase realname
        # to username/realname.
        all_people = {}
        for (username, realname) in user_info:
            all_people[username.lower()] = (username, realname)
            all_people[realname.lower()] = (username, realname)

    # Likewise, without a # we don't need project-info.
    if any(n.strip().startswith('#') for n in names):
        project_info = _get_project_info(arc_root, use_cache=use_arc_caches)
        all_projects = {}
        for project in project_info:
            # Keep the same format as all_people to make the below easier.
            all_projects['#' + project.lower()] = ('#' + project, project)

    # For each asked-for reviewer, find the set of people records that
    # reviewer could be referring to.  Hopefully it's exactly one!
    for name in names:
        name = name.strip().lower()
        if name.endswith('@'):           # indicates an exact match desired
            retval.append(name[:-1])
            continue
        if name.startswith('@'):         # also indicates an exact match
            retval.append(name[1:])
            continue

        if name.startswith('#'):   # it's a project
            all_candidates = all_projects
            dup_msg = 'There are a few projects matching "%s"' % name
        else:
            all_candidates = all_people
            dup_msg = 'There are a few folks matching "%s"' % name

        # First try the 'word' match.
        candidate_reviewers = set()
        for (person, username_and_realname) in all_candidates.iteritems():
            if name in person.split():    # name matches a word in 'person'
                candidate_reviewers.add(username_and_realname)

        # Then, if that doesn't work, move to 'substring' match.
        if not candidate_reviewers:
            for (person, username_and_realname) in all_candidates.iteritems():
                if name in person:        # name is a substring of 'person'
                    candidate_reviewers.add(username_and_realname)

        candidate_reviewers = sorted(candidate_reviewers)

        if not candidate_reviewers:   # no person matched the reviewer
            if use_arc_caches:
                # Try again without the cache; maybe we're seeking a new user
                return normalize_usernames(arc_root, names,
                                           use_arc_caches=False)
            raise NameError('No reviewer found matching "%s"' % name)
        elif len(candidate_reviewers) > 1:
            print '\nHmm...%s:' % dup_msg
            for (i, username_and_realname) in enumerate(candidate_reviewers):
                print '  %s. %s (%s)' % (i + 1, username_and_realname[0],
                                         username_and_realname[1])
            pick = _pick_a_number('Which "%s" did you mean? ' % name,
                                  len(candidate_reviewers))
            retval.append(candidate_reviewers[pick - 1][0])
        else:
            retval.append(candidate_reviewers[0][0])

    return retval


def _extract_flag(arc_args, extract, comma_separate=False):
    """A mini getopt-style parser that leaves all other args alone.

    Like getopt.getopt, but ignores flag values it doesn't recognize.
    TODO(csilvers): use argparse.parse_known_args() instead:
       http://docs.python.org/2/library/argparse.html#partial-parsing

    Arguments:
        arc_args: the arg-list for arc: sys.argv[1:]
        extract: the flag to extract, e.g. '--rr'
        comma_separate: if True, split arg values on commas.  This
           causes us to return ['v1', 'v2', 'v3'] for each of these:
              --extract=v1,v2,v3
              --extract=v1 --extract=v2 --extract=v3
              --extract=v1,v2 --extract=v3

    Returns:
       A pair: (new_arc_args, extract_values).
       new_arc_args is the same as arc_args, but with extract and its
       argument removed.  If extract occurs more than once, all
       occurrences are removed.  extract_values are the arguments
       found for extract, as a list.  (The list will have 0 values if
       extract never occurs, 1 if it occurs once, 2 if it occurs
       twice, etc.)  Duplicates are removed from extract_values;
       otherwise, order is preserved.
    """
    new_arc_args = []
    extract_args = []
    i = 0
    while i < len(arc_args):
        if arc_args[i] == extract:
            extract_arg = arc_args[i + 1]
            i += 2
        elif arc_args[i].startswith(extract + '='):
            extract_arg = arc_args[i][len(extract + '='):]
            i += 1
        else:
            extract_arg = None
            new_arc_args.append(arc_args[i])
            i += 1

        if extract_arg is not None:
            if comma_separate:
                new_args = [a.strip() for a in extract_arg.split(',')
                            if a.strip()]
            else:
                new_args = [extract_arg]
            # We only add in the arg if it's not already in extract_args.
            # This removes dups while preserving relative ordering of
            # the arguments, in case that's meaningful to the author.
            for arg in new_args:
                if arg not in extract_args: # could be made more efficient...
                    extract_args.append(arg)

    return (new_arc_args, extract_args)


def normalize_rr_flags(arc_root, arc_args):
    """Replace --rr=<n1> --rr=<n2> with --reviewers <normalized n2>,...

    arc takes a flag --reviewers phabricator_username1,username2,...
    For historical reasons, and because it's easier to type, we allow
    --rr to specify reviewers.  We also allow --rr to be specified
    multiple times.  Finally, we allow the name in --rr to be a subset
    of a username -- or even of a real name -- and to prompt to clarify
    if the name is ambiguous.

    We accept '--rr=<n1>', '--rr=<n1> --rr=<n2>', '--rr=<n1>,<n2>', or
    even '--rr=<n1> --rr=<n2>,<n3>'.  In each case, the equals sign
    can be omitted -- that is, a space is ok instead of an equals sign.

    This flag takes care of all of this.  While --rr only makes sense
    for 'arc diff', we do this cleanup for all commands: it can't hurt
    (since --rr isn't a legal flag for any arcanist command) and that
    way we don't have to try to figure out if a command is an alias
    for diff.

    Arguments:
      arc_root: the root of the arcanist repository on the local filesystem.
      arc_args: the arguments pass to arc (argv[1+]).
      rr: what flag to search for: could be --cc, etc.

    Returns:
      A modified version of arc_args, with --rr flags replaces if any
      are present.  If none are present, arc_args is returned verbatim.
    """
    (retval, rr_args) = _extract_flag(arc_args, '--rr', comma_separate=True)

    if rr_args:
        # We need to convert our permissive reviewer args with phab usernames.
        reviewer_args = normalize_usernames(arc_root, rr_args)
        # It should always be ok to put --reviewers as the first arg to diff,
        # right after the 'diff' arg itself (which is arc_args[0])
        retval.insert(1, '--reviewers')
        retval.insert(2, ','.join(reviewer_args))

    return retval


def normalize_cc_flags(arc_root, arc_args):
    """Like normalize_rr_flags, but for --cc."""
    (retval, cc_args) = _extract_flag(arc_args, '--cc', comma_separate=True)
    if cc_args:
        # TODO(csilvers): support mailing lists too, when conduit adds that.
        reviewer_args = normalize_usernames(arc_root, cc_args)
        retval.insert(1, '--cc')
        retval.insert(2, ','.join(reviewer_args))
    return retval


def add_onto_for_arc_land(arc_args):
    """Figure out the 'parent' of this branch, and land onto that."""
    assert arc_args[0] == 'land'
    # If --onto is already in arc_args, don't add it
    for arg in arc_args:
        if arg.startswith('--onto'):
            return arc_args

    # This gives an error for if this branch isn't a tracking branch.
    # In that case, we'll require an explicit '--onto'.  cf.
    # http://stackoverflow.com/questions/171550/find-out-which-remote-branch-a-local-branch-is-tracking
    try:
        parent = _git_call(['rev-parse', '--abbrev-ref',
                            '--symbolic-full-name', '@{u}'])
    except NotGitError:
        # If we're an .hg repo or something, don't worry about --onto.
        return arc_args
    except subprocess.CalledProcessError:
        raise RuntimeError('You must explicitly specify --onto when landing'
                           ' a non-tracking branch (but better is to set'
                           ' branch:autosetupmerge in your .gitconfig!).')
    if '/' in parent:
        # If the parent is remote, then can't run 'arc land' at all; they
        # should run 'arc amend; git push' instead.
        raise RuntimeError("You can't call 'arc land' from a remote tracking"
                           " branch (you should call it from a local feature"
                           " branch).  Run 'arc amend' + 'git push' instead.")

    return arc_args + ['--onto', parent.strip()]


def maybe_munge_browse_arg(arc_args):
    """If the browse arg is a commit-ish, try to replace it with a review."""
    # 'arc browse' takes one argument, so it should be the last word.
    # If 'browse' isn't followed by an arg, assume it's HEAD.
    if arc_args[-1] == 'browse':
        arc_args.append('HEAD')

    browse_arg = arc_args[-1]

    # Check if the arg is a commit-ish, and if so get the log message.
    try:
        log_message = _git_call(['log', browse_arg])
    except (subprocess.CalledProcessError, NotGitError):
        return arc_args     # Not a commit-ish, not in a git repo, ...

    # If the commit-ish indicates a phabricator review, use it!
    m = re.search((r'^\s*Differential Revision: '
                   r'https?://phabricator.khanacademy.org/(.+)'),
                  log_message, re.MULTILINE)

    if not m and browse_arg == 'HEAD':
        # Use 'arc which' to see if the review is a parent of head.
        which_output = subprocess.check_output(['arc', 'which'])
        m = re.search(r'^MATCHING REVISIONS.*?(D\d+)', which_output,
                      re.MULTILINE | re.DOTALL)

    if m:
        arc_args[-1] = m.group(1)
        print 'Loading %s (from %s)' % (arc_args[-1], browse_arg)

    return arc_args


def _get_subcommand(arc_args):
    """Return the arc command being run given args to 'arc'.

    For instance, for 'arc --trace --config key=value diff --update D435'
    it would return 'diff'.
    """
    if not arc_args:
        return None

    # TODO(csilvers): support --trace, --config, etc.
    return arc_args[0]


def _tee_communicate(cmd):
    """Given a command, return output *and* write to stdout/stderr.

    This code is based on code at https://stackoverflow.com/questions/52954248

    We return an (rc, stdout, stderr) triple.

    WARNING: this probably won't work on windows.
    """
    if sys.stdout.isatty():
        (out_master, out_slave) = pty.openpty()
    else:
        # out_master doesn't exist until after the call to Popen.
        out_slave = subprocess.PIPE
    if sys.stderr.isatty():
        (err_master, err_slave) = pty.openpty()
    else:
        # err_master doesn't exist until after the call to Popen.
        err_slave = subprocess.PIPE

    p = subprocess.Popen(
        cmd, bufsize=1, stdout=out_slave, stderr=err_slave, close_fds=True)

    if p.stdout:
        out_master = p.stdout.fileno()
    if p.stderr:
        err_master = p.stderr.fileno()
    if out_slave != subprocess.PIPE:
        os.close(out_slave)
    if err_slave != subprocess.PIPE:
        os.close(err_slave)

    readable = [out_master, err_master]
    result = {out_master: '', err_master: ''}
    try:
        while readable:
            try:
                ready, _, _ = select.select(readable, [], [])
            except select.error, e:
                if e.args[0] == errno.EINTR:
                    continue
                raise
            for fd in ready:
                try:
                    data = os.read(fd, 512)
                except OSError as e:
                    if e.errno != errno.EIO:
                        raise
                    # EIO means EOF on some systems
                    readable.remove(fd)
                else:
                    if not data: # EOF
                        readable.remove(fd)
                    result[fd] += data
                    if fd == out_master:
                        sys.stdout.write(data)
                    if fd == err_master:
                        sys.stderr.write(data)
    finally:
        rc = p.wait()
        return (rc, result[out_master], result[err_master])


def main(arc_args, arc_root=None):
    if arc_root is None:
        arc_root = _DEFAULT_ARC_ROOT

    arcanist_arc = os.path.join(arc_root, 'bin', 'arc')

    arc_subcommand = _get_subcommand(arc_args)

    _sync_arc(arc_root)

    # If they are trying to install a certificate, skip our fancy
    # work; it won't succeed anyway without the certificate!  (Better
    # would be to grep for '"cert"' in ~/.arcrc, but I don't want to
    # have to deal with parsing --arcrc-file.
    if arc_subcommand == 'install-certificate':
        # This never returns.
        os.execv(arcanist_arc, [arcanist_arc] + arc_args)

    # Handle any --rr flags that may be in arc_args (--rr is a khan extension).
    # Likewise with --cc; while --cc is a standard arc flag, we're more
    # permissive in what we accept (real names, not just usernames).
    arc_args = normalize_rr_flags(arc_root, arc_args)
    arc_args = normalize_cc_flags(arc_root, arc_args)

    if arc_subcommand == 'land':
        arc_args = add_onto_for_arc_land(arc_args)

    if arc_subcommand == 'browse':
        arc_args = maybe_munge_browse_arg(arc_args)

    # Now run the 'real' (arcanist) arc.
    (rc, stdout, stderr) = _tee_communicate([arcanist_arc] + arc_args)

    if '413 Request Entity Too Large' in stderr:
        print >>sys.stderr, "(Run `arc diff --less-context` to work around.)"

    if 'Command failed with error' in stderr and 'more bytes)' in stderr:
        commands = re.findall(r'COMMAND\s*(.*)', stderr)
        if commands:
            print >>sys.stderr, "To see the full error output, run:"
            print >>sys.stderr, '\n'.join(commands)

    sys.exit(rc)


if __name__ == '__main__':
    main(sys.argv[1:])
